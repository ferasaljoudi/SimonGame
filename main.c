/*
****************************************************************************************************************************
A simple Simon game with 10 levels designed with C code using Keil uVision
Also using: 
	-STM32F103 Nucleo Board
	-Breadboard
	-4 LEDs with common Cathode to GND and the Anodes going through Isolated Resistor 270ohm to the output of the STM32
	-4 push buttons. For each one, one side is connected to GND 
		and the other side is going through 10Kohm Bussed Resistor to the input in the STM32
	-An extra red LED, this will blink for 3 seconds if a fail occurred, to tell the player that a fail occurred.
	
When the code runs, the 4 LEDs will keep running as a classic Cylon Eye Scanner
When the player pushes the blue button in the STM32, the classic Cylon Eye Scanner stops and the game starts by generating the first random light
The player has to mimic the light by pressing the appropriate button
The player has a limited time to press the button
If the player succeeds, then the game moves to round two and adds an LED to the sequence. This will continue for 10 rounds
If the player fails to mimic the pattern in the time allotted then the failure sequence occur
In the failure sequence, the separated red LED will be blinking for 3 seconds
Then the player will see the level he reached represented in binary by the 4 LEDs 
If the player completes 10 rounds successfully, then the 4 LEDs will be blinking on and off together
****************************************************************************************************************************
*/

#include <stdlib.h>
#include <stdbool.h>
#include "main.h"

//To change the levels of the game, you can simply change the ROUNDS
#define ROUNDS 10

int main(void)
{
	unsigned int rands = 0;
	unsigned int statusIs = 0;
	int array[ROUNDS]; //Array of ROUNDS elements
  int count = 0;

	//Set the clock and congigure the pins
	GPIO_ClockInitAndConfiguring();
	//Start the game and return rands to be used for generating the first random number
	rands = StartTheGame();
	
	while (count < ROUNDS)
	{
		//Generate random light and store it in the array
		array[count] = genRand(rands);
		//turn the lights stored in the array
		turnRands(array, count);
		//check if the player pressed the right buttons within the limited time
		statusIs = checkSelection(array, count);
		delay(1000);
		if (statusIs == 0)
		{
			fail();
			result(count);
			return 0;
		}
		count++;
		rands = statusIs;
    }
	//Calling the passed function only if the player passed all levels
	passed();
	//If the player Won the game, no need for the result function
	//The 4 LEDs will be blinking ON and OFF togather by calling the passed function
	//result(count);
		
	//We do not need a return if all the levels are passed
	//instead we want the passed function to keep running
}
//-----------------------------------ENABILING&CONFIGURING FUNCTION-----------------------------------
void GPIO_ClockInitAndConfiguring(void)
{
	//This function will enable the clocks for ports A, B, and C
	//And it will configue the pins we are using
	//Then it will turn ON the green LED on the STM32
	uint32_t clear0to3Bits = 0xFFFFFFF0;
	uint32_t clear4to7Bits = 0xFFFFFF0F;
	uint32_t clear16to19Bits = 0xFFF0FFFF;
	uint32_t clear20to23Bits = 0xFF0FFFFF;
	uint32_t clear24to27Bits = 0xF0FFFFFF;
	
	//Turn on the clocks for Port A, B and Port C
	RCC->APB2ENR |= ((1 << 2) | (1 << 3) | (1 << 4));//setting bit 2, 3 and 4
	//congiguring PA0
	GPIOA->CRL &= clear0to3Bits;
	GPIOA->CRL |= 0x3;
	//congiguring PA1
	GPIOA->CRL &= clear4to7Bits;
	GPIOA->CRL |= (0x3 << 4);
	//congiguring PA4
	GPIOA->CRL &= clear16to19Bits;
	GPIOA->CRL |= (0x3 << 16);
	//congiguring PB0
	GPIOB->CRL &= clear0to3Bits;
	GPIOB->CRL |= 0x3;
	//congiguring PA5
	GPIOA->CRL &= clear20to23Bits;
	GPIOA->CRL |= (3 << 20);
	//congiguring PA6
	GPIOA->CRL &= clear24to27Bits;
	GPIOA->CRL |= (3 << 24);
	
	//Setting bit 5 for green LED on the STM32 to stay on
	GPIOA->ODR |= (1 << 5);
}
//-----------------------------------STARTTHEGAME FUNCTION-----------------------------------
unsigned int StartTheGame(void)
{
	//This function will start the game by a classic Cylon Eye Scanner generated by 4 LEDs
	uint32_t clearbitA0 = 0xFFFFFFFE;
	uint32_t clearbitA1 = 0xFFFFFFFD;
	uint32_t clearbitA4 = 0xFFFFFFEF;
	uint32_t clearbitB0 = 0xFFFFFFFE;
	//The count from this function will be used to generate the first random number
	unsigned int count = 0;
	//i will be used at the end of this function in the second while loop
	unsigned int i = 0;
	//The while loop will keep the classic Cylon Eye Scanner running
	//until the player press the start button (the blue button on the STM32)
	while (1)
	{
		GPIOA->ODR |= (1 << 0);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		delay(750);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		GPIOA->ODR &= clearbitA0;
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		
		count++;
		
		GPIOA->ODR |= (1 << 1);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		delay(750);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		GPIOA->ODR &= clearbitA1;
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		
		count++;

		GPIOA->ODR |= (1 << 4);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		delay(750);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		GPIOA->ODR &= clearbitA4;
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		
		count++;

		GPIOB->ODR |= (1 << 0);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		delay(750);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		GPIOB->ODR &= clearbitB0;
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		
		count++;
		
		GPIOA->ODR |= (1 << 4);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		delay(750);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		GPIOA->ODR &= clearbitA4;
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		
		count++;
		
		GPIOA->ODR |= (1 << 1);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		delay(750);
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		GPIOA->ODR &= clearbitA1;
		if ((GPIOC->IDR & (1 << 13)) == 0) break;
		
		count++;
	}
	GPIOA->ODR &= clearbitA0;
	GPIOA->ODR &= clearbitA1;
	GPIOA->ODR &= clearbitA4;
	GPIOB->ODR &= clearbitB0;
	
	//After the player press the start button
	//the 4 LEDs will turn ON and OFF togather 3 times
	//telling the player: "Ready...Set...Go..."
	while (i < 3)
	{
		GPIOA->ODR |= (1 << 0);
		GPIOA->ODR |= (1 << 1);
		GPIOA->ODR |= (1 << 4);
		GPIOB->ODR |= (1 << 0);
		delay(1500);
		GPIOA->ODR &= clearbitA0;
		GPIOA->ODR &= clearbitA1;
		GPIOA->ODR &= clearbitA4;
		GPIOB->ODR &= clearbitB0;
		delay(1500);
		i++;
	}
	
	return count;
}
//-----------------------------------GENRAND FUNCTION-----------------------------------
int genRand(unsigned int rands)
{
	//This function will generate a random number
	//Since the MSB is more randomized than the LSB usually
	//And since the MSB is for the sign
	//And since we need 4 options for 4 LEDs
	//will take bit 30 and bit 29 and determain the LED
	int randomNumber = 0;
	unsigned int LIGHTMASK = 0x00000003;
	srand(rands);
	
	randomNumber = rand();
	randomNumber = randomNumber >> 29;
	randomNumber &= LIGHTMASK;
	
	return randomNumber;
}
//-----------------------------------TURNRANDS FUNCTION-----------------------------------
void turnRands(int *array, int count)
{
	//This function will turn the LEDs ON then OFF
	//The LEDs are already determained by the genRand function and passed here in the array
	uint32_t clearbitA0 = 0xFFFFFFFE;
	uint32_t clearbitA1 = 0xFFFFFFFD;
	uint32_t clearbitA4 = 0xFFFFFFEF;
	uint32_t clearbitB0 = 0xFFFFFFFE;
	int i = 0;
	
	while(i <= count)
	{
		switch (array[i])
		{
			case 0:
				GPIOA->ODR |= (1 << 0);
				delay(1000);
				GPIOA->ODR &= clearbitA0;
				delay(1000);
				break;
			case 1:
				GPIOA->ODR |= (1 << 1);
				delay(1000);
				GPIOA->ODR &= clearbitA1;
				delay(1000);
				break;
			case 2:
				GPIOA->ODR |= (1 << 4);
				delay(1000);
				GPIOA->ODR &= clearbitA4;
				delay(1000);
				break;
			case 3:
				GPIOB->ODR |= (1 << 0);
				delay(1000);
				GPIOB->ODR &= clearbitB0;
				delay(1000);
				break;
		}
		i++;
	}
}
//-----------------------------------CHECKSELECTION FUNCTION-----------------------------------
unsigned int checkSelection(int *array, int count)
{
	//This function will check if the player pressed the right button within the limited time
	unsigned int rands = 0;
	int i = 0;
	int check = 0;
	//The rands will be returned from this function and have two purposes:
	//if rands is 0, fails occurred
	//if rands is not 0, will pass it to genRand() function, to generate a random number and determine the next light 
	
	while((i <= count) && check == i )
	{
		unsigned int start_time = 0;
		unsigned int current_time = 0;
		start_time = current_time;
		while (current_time - start_time < 500000)
		{
			rands += 10;
			//Very short delay
			delay(12);
			//Manually incrementing the current time
			current_time += 10;
			if (((array[i] == 0) && ((GPIOB->IDR & (1 << 4)) == 0)) || ((array[i] == 1) && ((GPIOB->IDR & (1 << 6)) == 0))
				|| ((array[i] == 2) && ((GPIOB->IDR & (1 << 8)) == 0)) || ((array[i] == 3) && ((GPIOB->IDR & (1 << 9)) == 0)))
			{
				check++;
				delay(1000);
				break;
			}else if ((((array[i] == 0) && ((GPIOB->IDR & (1 << 6)) == 0)) || ((array[i] == 0) && ((GPIOB->IDR & (1 << 8)) == 0))
								|| ((array[i] == 0) && ((GPIOB->IDR & (1 << 9)) == 0)))
								|| (((array[i] == 1) && ((GPIOB->IDR & (1 << 4)) == 0)) || ((array[i] == 1) && ((GPIOB->IDR & (1 << 8)) == 0))
								|| ((array[i] == 1) && ((GPIOB->IDR & (1 << 9)) == 0)))
								|| (((array[i] == 2) && ((GPIOB->IDR & (1 << 4)) == 0)) || ((array[i] == 2) && ((GPIOB->IDR & (1 << 6)) == 0))
								|| ((array[i] == 2) && ((GPIOB->IDR & (1 << 9)) == 0)))
								|| (((array[i] == 3) && ((GPIOB->IDR & (1 << 6)) == 0)) || ((array[i] == 3) && ((GPIOB->IDR & (1 << 8)) == 0))
								|| ((array[i] == 3) && ((GPIOB->IDR & (1 << 4)) == 0))))
			{
				//If the player pressed the wrong button, break the while loop
				check = -1;
				break;
			}
		}
		i++;
	}
	if (check != i)
	{
		return 0;
	}
	else
	{
		return rands;
	}
}
//-----------------------------------FAIL FUNCTION-----------------------------------
void fail(void)
{
	//If the player fails at any level, the seperated red LEDs will be blinking for 3 seconds
	uint32_t clearbitA6 = 0xFFFFFFBF;
	unsigned int start_time = 0;
	unsigned int current_time = 0;
	start_time = current_time;
	while (current_time - start_time < 150)
	{
		current_time += 10;
		GPIOA->ODR |= (1 << 6);
		delay(600);
		GPIOA->ODR &= clearbitA6;
		delay(600);
	}
}
//-----------------------------------PASSED FUNCTION-----------------------------------
void passed(void)
{
	//Note that the passed function will only be called if the player passed all the levels
	//The passed function will make the 4 LEDs keep blinking ON and OFF togather
	uint32_t clearbitA0 = 0xFFFFFFFE;
	uint32_t clearbitA1 = 0xFFFFFFFD;
	uint32_t clearbitA4 = 0xFFFFFFEF;
	uint32_t clearbitB0 = 0xFFFFFFFE;
	while(1)
	{
		GPIOA->ODR |= (1 << 0);
		GPIOA->ODR |= (1 << 1);
		GPIOA->ODR |= (1 << 4);
		GPIOB->ODR |= (1 << 0);
		delay(1000);
		GPIOA->ODR &= clearbitA0;
		GPIOA->ODR &= clearbitA1;
		GPIOA->ODR &= clearbitA4;
		GPIOB->ODR &= clearbitB0;
		delay(1000);
	}
}
//-----------------------------------RESULT FUNCTION-----------------------------------
void result(int results)
{
	//After the fail function runs,
	//the result function will display the highest level the player won in binary using 4 LEDs
	switch (results)
	{
		//All lights off for 0->0000
		case 0:
			break;
		//1->0001
		case 1:
			GPIOB->ODR |= (1 << 0);
			break;
		//2->0010
		case 2:
			GPIOA->ODR |= (1 << 4);
			break;
		//3->0011
		case 3:
			GPIOB->ODR |= (1 << 0);
			GPIOA->ODR |= (1 << 4);
			break;
		//4->0100
		case 4:
			GPIOA->ODR |= (1 << 1);
			break;
		//5->0101
		case 5:
			GPIOA->ODR |= (1 << 1);
			GPIOB->ODR |= (1 << 0);
			break;
		//6->0110
		case 6:
			GPIOA->ODR |= (1 << 1);
			GPIOA->ODR |= (1 << 4);
			break;
		//7->0111
		case 7:
			GPIOA->ODR |= (1 << 1);
			GPIOA->ODR |= (1 << 4);
			GPIOB->ODR |= (1 << 0);
			break;
		//8->1000
		case 8:
			GPIOA->ODR |= (1 << 0);
			break;
		//9->1001
		case 9:
			GPIOA->ODR |= (1 << 0);
			GPIOB->ODR |= (1 << 0);
			break;
		//10->1010
		case 10:
			GPIOA->ODR |= (1 << 0);
			GPIOA->ODR |= (1 << 4);
			break;
	}
}
//-----------------------------------DELAY FUNCTION-----------------------------------
void delay(unsigned int delayVal)
{
	unsigned int i = 0;
	unsigned int y = 0;
	unsigned int internalDelay = 0;
	
	internalDelay = delayVal;
	while(i < delayVal)
	{
		
		while(y < internalDelay)
		{
			++y;
		}
		y = 0;
		++i;
	}
}

